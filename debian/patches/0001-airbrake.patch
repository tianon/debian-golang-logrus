Description: Remove airbrake
Author: Jessica Frazelle <jess@docker.com>
Last-Update: 2015-01-12
Forwarded: not-needed
Origin: vendor

---
 examples/hook/hook.go               |  35 -----
 hook_test.go                        | 122 ------------------
 hooks/airbrake/airbrake.go          |  54 --------
 hooks/papertrail/README.md          |  28 ----
 hooks/papertrail/papertrail.go      |  54 --------
 hooks/papertrail/papertrail_test.go |  26 ----
 logrus_test.go                      | 247 ------------------------------------
 7 files changed, 566 deletions(-)
 delete mode 100644 examples/hook/hook.go
 delete mode 100644 hook_test.go
 delete mode 100644 hooks/airbrake/airbrake.go
 delete mode 100644 hooks/papertrail/README.md
 delete mode 100644 hooks/papertrail/papertrail.go
 delete mode 100644 hooks/papertrail/papertrail_test.go
 delete mode 100644 logrus_test.go

diff --git a/examples/hook/hook.go b/examples/hook/hook.go
deleted file mode 100644
index 42e7a4c..0000000
--- a/examples/hook/hook.go
+++ /dev/null
@@ -1,35 +0,0 @@
-package main
-
-import (
-	"github.com/Sirupsen/logrus"
-	"github.com/Sirupsen/logrus/hooks/airbrake"
-	"github.com/tobi/airbrake-go"
-)
-
-var log = logrus.New()
-
-func init() {
-	log.Formatter = new(logrus.TextFormatter) // default
-	log.Hooks.Add(new(logrus_airbrake.AirbrakeHook))
-}
-
-func main() {
-	airbrake.Endpoint = "https://exceptions.whatever.com/notifier_api/v2/notices.xml"
-	airbrake.ApiKey = "whatever"
-	airbrake.Environment = "production"
-
-	log.WithFields(logrus.Fields{
-		"animal": "walrus",
-		"size":   10,
-	}).Info("A group of walrus emerges from the ocean")
-
-	log.WithFields(logrus.Fields{
-		"omg":    true,
-		"number": 122,
-	}).Warn("The group's number increased tremendously!")
-
-	log.WithFields(logrus.Fields{
-		"omg":    true,
-		"number": 100,
-	}).Fatal("The ice breaks!")
-}
diff --git a/hook_test.go b/hook_test.go
deleted file mode 100644
index 13f34cb..0000000
--- a/hook_test.go
+++ /dev/null
@@ -1,122 +0,0 @@
-package logrus
-
-import (
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-)
-
-type TestHook struct {
-	Fired bool
-}
-
-func (hook *TestHook) Fire(entry *Entry) error {
-	hook.Fired = true
-	return nil
-}
-
-func (hook *TestHook) Levels() []Level {
-	return []Level{
-		DebugLevel,
-		InfoLevel,
-		WarnLevel,
-		ErrorLevel,
-		FatalLevel,
-		PanicLevel,
-	}
-}
-
-func TestHookFires(t *testing.T) {
-	hook := new(TestHook)
-
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Hooks.Add(hook)
-		assert.Equal(t, hook.Fired, false)
-
-		log.Print("test")
-	}, func(fields Fields) {
-		assert.Equal(t, hook.Fired, true)
-	})
-}
-
-type ModifyHook struct {
-}
-
-func (hook *ModifyHook) Fire(entry *Entry) error {
-	entry.Data["wow"] = "whale"
-	return nil
-}
-
-func (hook *ModifyHook) Levels() []Level {
-	return []Level{
-		DebugLevel,
-		InfoLevel,
-		WarnLevel,
-		ErrorLevel,
-		FatalLevel,
-		PanicLevel,
-	}
-}
-
-func TestHookCanModifyEntry(t *testing.T) {
-	hook := new(ModifyHook)
-
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Hooks.Add(hook)
-		log.WithField("wow", "elephant").Print("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["wow"], "whale")
-	})
-}
-
-func TestCanFireMultipleHooks(t *testing.T) {
-	hook1 := new(ModifyHook)
-	hook2 := new(TestHook)
-
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Hooks.Add(hook1)
-		log.Hooks.Add(hook2)
-
-		log.WithField("wow", "elephant").Print("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["wow"], "whale")
-		assert.Equal(t, hook2.Fired, true)
-	})
-}
-
-type ErrorHook struct {
-	Fired bool
-}
-
-func (hook *ErrorHook) Fire(entry *Entry) error {
-	hook.Fired = true
-	return nil
-}
-
-func (hook *ErrorHook) Levels() []Level {
-	return []Level{
-		ErrorLevel,
-	}
-}
-
-func TestErrorHookShouldntFireOnInfo(t *testing.T) {
-	hook := new(ErrorHook)
-
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Hooks.Add(hook)
-		log.Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, hook.Fired, false)
-	})
-}
-
-func TestErrorHookShouldFireOnError(t *testing.T) {
-	hook := new(ErrorHook)
-
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Hooks.Add(hook)
-		log.Error("test")
-	}, func(fields Fields) {
-		assert.Equal(t, hook.Fired, true)
-	})
-}
diff --git a/hooks/airbrake/airbrake.go b/hooks/airbrake/airbrake.go
deleted file mode 100644
index 880d21e..0000000
--- a/hooks/airbrake/airbrake.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package logrus_airbrake
-
-import (
-	"github.com/Sirupsen/logrus"
-	"github.com/tobi/airbrake-go"
-)
-
-// AirbrakeHook to send exceptions to an exception-tracking service compatible
-// with the Airbrake API. You must set:
-// * airbrake.Endpoint
-// * airbrake.ApiKey
-// * airbrake.Environment (only sends exceptions when set to "production")
-//
-// Before using this hook, to send an error. Entries that trigger an Error,
-// Fatal or Panic should now include an "error" field to send to Airbrake.
-type AirbrakeHook struct{}
-
-func (hook *AirbrakeHook) Fire(entry *logrus.Entry) error {
-	if entry.Data["error"] == nil {
-		entry.Logger.WithFields(logrus.Fields{
-			"source":   "airbrake",
-			"endpoint": airbrake.Endpoint,
-		}).Warn("Exceptions sent to Airbrake must have an 'error' key with the error")
-		return nil
-	}
-
-	err, ok := entry.Data["error"].(error)
-	if !ok {
-		entry.Logger.WithFields(logrus.Fields{
-			"source":   "airbrake",
-			"endpoint": airbrake.Endpoint,
-		}).Warn("Exceptions sent to Airbrake must have an `error` key of type `error`")
-		return nil
-	}
-
-	airErr := airbrake.Notify(err)
-	if airErr != nil {
-		entry.Logger.WithFields(logrus.Fields{
-			"source":   "airbrake",
-			"endpoint": airbrake.Endpoint,
-			"error":    airErr,
-		}).Warn("Failed to send error to Airbrake")
-	}
-
-	return nil
-}
-
-func (hook *AirbrakeHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.ErrorLevel,
-		logrus.FatalLevel,
-		logrus.PanicLevel,
-	}
-}
diff --git a/hooks/papertrail/README.md b/hooks/papertrail/README.md
deleted file mode 100644
index ae61e92..0000000
--- a/hooks/papertrail/README.md
+++ /dev/null
@@ -1,28 +0,0 @@
-# Papertrail Hook for Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:" />
-
-[Papertrail](https://papertrailapp.com) provides hosted log management. Once stored in Papertrail, you can [group](http://help.papertrailapp.com/kb/how-it-works/groups/) your logs on various dimensions, [search](http://help.papertrailapp.com/kb/how-it-works/search-syntax) them, and trigger [alerts](http://help.papertrailapp.com/kb/how-it-works/alerts).
-
-In most deployments, you'll want to send logs to Papertrail via their [remote_syslog](http://help.papertrailapp.com/kb/configuration/configuring-centralized-logging-from-text-log-files-in-unix/) daemon, which requires no application-specific configuration. This hook is intended for relatively low-volume logging, likely in managed cloud hosting deployments where installing `remote_syslog` is not possible.
-
-## Usage
-
-You can find your Papertrail UDP port on your [Papertrail account page](https://papertrailapp.com/account/destinations). Substitute it below for `YOUR_PAPERTRAIL_UDP_PORT`.
-
-For `YOUR_APP_NAME`, substitute a short string that will readily identify your application or service in the logs.
-
-```go
-import (
-  "log/syslog"
-  "github.com/Sirupsen/logrus"
-  "github.com/Sirupsen/logrus/hooks/papertrail"
-)
-
-func main() {
-  log       := logrus.New()
-  hook, err := logrus_papertrail.NewPapertrailHook("logs.papertrailapp.com", YOUR_PAPERTRAIL_UDP_PORT, YOUR_APP_NAME)
-
-  if err == nil {
-    log.Hooks.Add(hook)
-  }
-}
-```
diff --git a/hooks/papertrail/papertrail.go b/hooks/papertrail/papertrail.go
deleted file mode 100644
index 48e2fea..0000000
--- a/hooks/papertrail/papertrail.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package logrus_papertrail
-
-import (
-	"fmt"
-	"net"
-	"os"
-	"time"
-
-	"github.com/Sirupsen/logrus"
-)
-
-const (
-	format = "Jan 2 15:04:05"
-)
-
-// PapertrailHook to send logs to a logging service compatible with the Papertrail API.
-type PapertrailHook struct {
-	Host    string
-	Port    int
-	AppName string
-	UDPConn net.Conn
-}
-
-// NewPapertrailHook creates a hook to be added to an instance of logger.
-func NewPapertrailHook(host string, port int, appName string) (*PapertrailHook, error) {
-	conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", host, port))
-	return &PapertrailHook{host, port, appName, conn}, err
-}
-
-// Fire is called when a log event is fired.
-func (hook *PapertrailHook) Fire(entry *logrus.Entry) error {
-	date := time.Now().Format(format)
-	payload := fmt.Sprintf("<22> %s %s: [%s] %s", date, hook.AppName, entry.Data["level"], entry.Message)
-
-	bytesWritten, err := hook.UDPConn.Write([]byte(payload))
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Unable to send log line to Papertrail via UDP. Wrote %d bytes before error: %v", bytesWritten, err)
-		return err
-	}
-
-	return nil
-}
-
-// Levels returns the available logging levels.
-func (hook *PapertrailHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.PanicLevel,
-		logrus.FatalLevel,
-		logrus.ErrorLevel,
-		logrus.WarnLevel,
-		logrus.InfoLevel,
-		logrus.DebugLevel,
-	}
-}
diff --git a/hooks/papertrail/papertrail_test.go b/hooks/papertrail/papertrail_test.go
deleted file mode 100644
index 96318d0..0000000
--- a/hooks/papertrail/papertrail_test.go
+++ /dev/null
@@ -1,26 +0,0 @@
-package logrus_papertrail
-
-import (
-	"fmt"
-	"testing"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/stvp/go-udp-testing"
-)
-
-func TestWritingToUDP(t *testing.T) {
-	port := 16661
-	udp.SetAddr(fmt.Sprintf(":%d", port))
-
-	hook, err := NewPapertrailHook("localhost", port, "test")
-	if err != nil {
-		t.Errorf("Unable to connect to local UDP server.")
-	}
-
-	log := logrus.New()
-	log.Hooks.Add(hook)
-
-	udp.ShouldReceive(t, "foo", func() {
-		log.Info("foo")
-	})
-}
diff --git a/logrus_test.go b/logrus_test.go
deleted file mode 100644
index 15157d1..0000000
--- a/logrus_test.go
+++ /dev/null
@@ -1,247 +0,0 @@
-package logrus
-
-import (
-	"bytes"
-	"encoding/json"
-	"strconv"
-	"strings"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-)
-
-func LogAndAssertJSON(t *testing.T, log func(*Logger), assertions func(fields Fields)) {
-	var buffer bytes.Buffer
-	var fields Fields
-
-	logger := New()
-	logger.Out = &buffer
-	logger.Formatter = new(JSONFormatter)
-
-	log(logger)
-
-	err := json.Unmarshal(buffer.Bytes(), &fields)
-	assert.Nil(t, err)
-
-	assertions(fields)
-}
-
-func LogAndAssertText(t *testing.T, log func(*Logger), assertions func(fields map[string]string)) {
-	var buffer bytes.Buffer
-
-	logger := New()
-	logger.Out = &buffer
-	logger.Formatter = &TextFormatter{
-		DisableColors: true,
-	}
-
-	log(logger)
-
-	fields := make(map[string]string)
-	for _, kv := range strings.Split(buffer.String(), " ") {
-		if !strings.Contains(kv, "=") {
-			continue
-		}
-		kvArr := strings.Split(kv, "=")
-		key := strings.TrimSpace(kvArr[0])
-		val, err := strconv.Unquote(kvArr[1])
-		assert.NoError(t, err)
-		fields[key] = val
-	}
-	assertions(fields)
-}
-
-func TestPrint(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Print("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test")
-		assert.Equal(t, fields["level"], "info")
-	})
-}
-
-func TestInfo(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test")
-		assert.Equal(t, fields["level"], "info")
-	})
-}
-
-func TestWarn(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Warn("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test")
-		assert.Equal(t, fields["level"], "warning")
-	})
-}
-
-func TestInfolnShouldAddSpacesBetweenStrings(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Infoln("test", "test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test test")
-	})
-}
-
-func TestInfolnShouldAddSpacesBetweenStringAndNonstring(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Infoln("test", 10)
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test 10")
-	})
-}
-
-func TestInfolnShouldAddSpacesBetweenTwoNonStrings(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Infoln(10, 10)
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "10 10")
-	})
-}
-
-func TestInfoShouldAddSpacesBetweenTwoNonStrings(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Infoln(10, 10)
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "10 10")
-	})
-}
-
-func TestInfoShouldNotAddSpacesBetweenStringAndNonstring(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Info("test", 10)
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test10")
-	})
-}
-
-func TestInfoShouldNotAddSpacesBetweenStrings(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.Info("test", "test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "testtest")
-	})
-}
-
-func TestWithFieldsShouldAllowAssignments(t *testing.T) {
-	var buffer bytes.Buffer
-	var fields Fields
-
-	logger := New()
-	logger.Out = &buffer
-	logger.Formatter = new(JSONFormatter)
-
-	localLog := logger.WithFields(Fields{
-		"key1": "value1",
-	})
-
-	localLog.WithField("key2", "value2").Info("test")
-	err := json.Unmarshal(buffer.Bytes(), &fields)
-	assert.Nil(t, err)
-
-	assert.Equal(t, "value2", fields["key2"])
-	assert.Equal(t, "value1", fields["key1"])
-
-	buffer = bytes.Buffer{}
-	fields = Fields{}
-	localLog.Info("test")
-	err = json.Unmarshal(buffer.Bytes(), &fields)
-	assert.Nil(t, err)
-
-	_, ok := fields["key2"]
-	assert.Equal(t, false, ok)
-	assert.Equal(t, "value1", fields["key1"])
-}
-
-func TestUserSuppliedFieldDoesNotOverwriteDefaults(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.WithField("msg", "hello").Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test")
-	})
-}
-
-func TestUserSuppliedMsgFieldHasPrefix(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.WithField("msg", "hello").Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["msg"], "test")
-		assert.Equal(t, fields["fields.msg"], "hello")
-	})
-}
-
-func TestUserSuppliedTimeFieldHasPrefix(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.WithField("time", "hello").Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["fields.time"], "hello")
-	})
-}
-
-func TestUserSuppliedLevelFieldHasPrefix(t *testing.T) {
-	LogAndAssertJSON(t, func(log *Logger) {
-		log.WithField("level", 1).Info("test")
-	}, func(fields Fields) {
-		assert.Equal(t, fields["level"], "info")
-		assert.Equal(t, fields["fields.level"], 1)
-	})
-}
-
-func TestDefaultFieldsAreNotPrefixed(t *testing.T) {
-	LogAndAssertText(t, func(log *Logger) {
-		ll := log.WithField("herp", "derp")
-		ll.Info("hello")
-		ll.Info("bye")
-	}, func(fields map[string]string) {
-		for _, fieldName := range []string{"fields.level", "fields.time", "fields.msg"} {
-			if _, ok := fields[fieldName]; ok {
-				t.Fatalf("should not have prefixed %q: %v", fieldName, fields)
-			}
-		}
-	})
-}
-
-func TestConvertLevelToString(t *testing.T) {
-	assert.Equal(t, "debug", DebugLevel.String())
-	assert.Equal(t, "info", InfoLevel.String())
-	assert.Equal(t, "warning", WarnLevel.String())
-	assert.Equal(t, "error", ErrorLevel.String())
-	assert.Equal(t, "fatal", FatalLevel.String())
-	assert.Equal(t, "panic", PanicLevel.String())
-}
-
-func TestParseLevel(t *testing.T) {
-	l, err := ParseLevel("panic")
-	assert.Nil(t, err)
-	assert.Equal(t, PanicLevel, l)
-
-	l, err = ParseLevel("fatal")
-	assert.Nil(t, err)
-	assert.Equal(t, FatalLevel, l)
-
-	l, err = ParseLevel("error")
-	assert.Nil(t, err)
-	assert.Equal(t, ErrorLevel, l)
-
-	l, err = ParseLevel("warn")
-	assert.Nil(t, err)
-	assert.Equal(t, WarnLevel, l)
-
-	l, err = ParseLevel("warning")
-	assert.Nil(t, err)
-	assert.Equal(t, WarnLevel, l)
-
-	l, err = ParseLevel("info")
-	assert.Nil(t, err)
-	assert.Equal(t, InfoLevel, l)
-
-	l, err = ParseLevel("debug")
-	assert.Nil(t, err)
-	assert.Equal(t, DebugLevel, l)
-
-	l, err = ParseLevel("invalid")
-	assert.Equal(t, "not a valid logrus Level: \"invalid\"", err.Error())
-}
-- 
2.1.4

