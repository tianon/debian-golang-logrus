Description: Remove hooks and hook examples that have failing tests
Author: Jessica Frazelle <jess@docker.com>
Last-Update: 2015-03-24
Forwarded: not-needed
Origin: vendor

---

Index: logrus/examples/hook/hook.go
===================================================================
--- logrus.orig/examples/hook/hook.go
+++ /dev/null
@@ -1,30 +0,0 @@
-package main
-
-import (
-	"github.com/Sirupsen/logrus"
-	"github.com/Sirupsen/logrus/hooks/airbrake"
-)
-
-var log = logrus.New()
-
-func init() {
-	log.Formatter = new(logrus.TextFormatter) // default
-	log.Hooks.Add(airbrake.NewHook("https://example.com", "xyz", "development"))
-}
-
-func main() {
-	log.WithFields(logrus.Fields{
-		"animal": "walrus",
-		"size":   10,
-	}).Info("A group of walrus emerges from the ocean")
-
-	log.WithFields(logrus.Fields{
-		"omg":    true,
-		"number": 122,
-	}).Warn("The group's number increased tremendously!")
-
-	log.WithFields(logrus.Fields{
-		"omg":    true,
-		"number": 100,
-	}).Fatal("The ice breaks!")
-}
Index: logrus/hooks/airbrake/airbrake.go
===================================================================
--- logrus.orig/hooks/airbrake/airbrake.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package airbrake
-
-import (
-	"errors"
-	"fmt"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/tobi/airbrake-go"
-)
-
-// AirbrakeHook to send exceptions to an exception-tracking service compatible
-// with the Airbrake API.
-type airbrakeHook struct {
-	APIKey      string
-	Endpoint    string
-	Environment string
-}
-
-func NewHook(endpoint, apiKey, env string) *airbrakeHook {
-	return &airbrakeHook{
-		APIKey:      apiKey,
-		Endpoint:    endpoint,
-		Environment: env,
-	}
-}
-
-func (hook *airbrakeHook) Fire(entry *logrus.Entry) error {
-	airbrake.ApiKey = hook.APIKey
-	airbrake.Endpoint = hook.Endpoint
-	airbrake.Environment = hook.Environment
-
-	var notifyErr error
-	err, ok := entry.Data["error"].(error)
-	if ok {
-		notifyErr = err
-	} else {
-		notifyErr = errors.New(entry.Message)
-	}
-
-	airErr := airbrake.Notify(notifyErr)
-	if airErr != nil {
-		return fmt.Errorf("Failed to send error to Airbrake: %s", airErr)
-	}
-
-	return nil
-}
-
-func (hook *airbrakeHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.ErrorLevel,
-		logrus.FatalLevel,
-		logrus.PanicLevel,
-	}
-}
Index: logrus/hooks/airbrake/airbrake_test.go
===================================================================
--- logrus.orig/hooks/airbrake/airbrake_test.go
+++ /dev/null
@@ -1,133 +0,0 @@
-package airbrake
-
-import (
-	"encoding/xml"
-	"net/http"
-	"net/http/httptest"
-	"testing"
-	"time"
-
-	"github.com/Sirupsen/logrus"
-)
-
-type notice struct {
-	Error NoticeError `xml:"error"`
-}
-type NoticeError struct {
-	Class   string `xml:"class"`
-	Message string `xml:"message"`
-}
-
-type customErr struct {
-	msg string
-}
-
-func (e *customErr) Error() string {
-	return e.msg
-}
-
-const (
-	testAPIKey    = "abcxyz"
-	testEnv       = "development"
-	expectedClass = "*airbrake.customErr"
-	expectedMsg   = "foo"
-	unintendedMsg = "Airbrake will not see this string"
-)
-
-var (
-	noticeError = make(chan NoticeError, 1)
-)
-
-// TestLogEntryMessageReceived checks if invoking Logrus' log.Error
-// method causes an XML payload containing the log entry message is received
-// by a HTTP server emulating an Airbrake-compatible endpoint.
-func TestLogEntryMessageReceived(t *testing.T) {
-	log := logrus.New()
-	ts := startAirbrakeServer(t)
-	defer ts.Close()
-
-	hook := NewHook(ts.URL, testAPIKey, "production")
-	log.Hooks.Add(hook)
-
-	log.Error(expectedMsg)
-
-	select {
-	case received := <-noticeError:
-		if received.Message != expectedMsg {
-			t.Errorf("Unexpected message received: %s", received.Message)
-		}
-	case <-time.After(time.Second):
-		t.Error("Timed out; no notice received by Airbrake API")
-	}
-}
-
-// TestLogEntryMessageReceived confirms that, when passing an error type using
-// logrus.Fields, a HTTP server emulating an Airbrake endpoint receives the
-// error message returned by the Error() method on the error interface
-// rather than the logrus.Entry.Message string.
-func TestLogEntryWithErrorReceived(t *testing.T) {
-	log := logrus.New()
-	ts := startAirbrakeServer(t)
-	defer ts.Close()
-
-	hook := NewHook(ts.URL, testAPIKey, "production")
-	log.Hooks.Add(hook)
-
-	log.WithFields(logrus.Fields{
-		"error": &customErr{expectedMsg},
-	}).Error(unintendedMsg)
-
-	select {
-	case received := <-noticeError:
-		if received.Message != expectedMsg {
-			t.Errorf("Unexpected message received: %s", received.Message)
-		}
-		if received.Class != expectedClass {
-			t.Errorf("Unexpected error class: %s", received.Class)
-		}
-	case <-time.After(time.Second):
-		t.Error("Timed out; no notice received by Airbrake API")
-	}
-}
-
-// TestLogEntryWithNonErrorTypeNotReceived confirms that, when passing a
-// non-error type using logrus.Fields, a HTTP server emulating an Airbrake
-// endpoint receives the logrus.Entry.Message string.
-//
-// Only error types are supported when setting the 'error' field using
-// logrus.WithFields().
-func TestLogEntryWithNonErrorTypeNotReceived(t *testing.T) {
-	log := logrus.New()
-	ts := startAirbrakeServer(t)
-	defer ts.Close()
-
-	hook := NewHook(ts.URL, testAPIKey, "production")
-	log.Hooks.Add(hook)
-
-	log.WithFields(logrus.Fields{
-		"error": expectedMsg,
-	}).Error(unintendedMsg)
-
-	select {
-	case received := <-noticeError:
-		if received.Message != unintendedMsg {
-			t.Errorf("Unexpected message received: %s", received.Message)
-		}
-	case <-time.After(time.Second):
-		t.Error("Timed out; no notice received by Airbrake API")
-	}
-}
-
-func startAirbrakeServer(t *testing.T) *httptest.Server {
-	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		var notice notice
-		if err := xml.NewDecoder(r.Body).Decode(&notice); err != nil {
-			t.Error(err)
-		}
-		r.Body.Close()
-
-		noticeError <- notice.Error
-	}))
-
-	return ts
-}
Index: logrus/hooks/bugsnag/bugsnag.go
===================================================================
--- logrus.orig/hooks/bugsnag/bugsnag.go
+++ /dev/null
@@ -1,68 +0,0 @@
-package logrus_bugsnag
-
-import (
-	"errors"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/bugsnag/bugsnag-go"
-)
-
-type bugsnagHook struct{}
-
-// ErrBugsnagUnconfigured is returned if NewBugsnagHook is called before
-// bugsnag.Configure. Bugsnag must be configured before the hook.
-var ErrBugsnagUnconfigured = errors.New("bugsnag must be configured before installing this logrus hook")
-
-// ErrBugsnagSendFailed indicates that the hook failed to submit an error to
-// bugsnag. The error was successfully generated, but `bugsnag.Notify()`
-// failed.
-type ErrBugsnagSendFailed struct {
-	err error
-}
-
-func (e ErrBugsnagSendFailed) Error() string {
-	return "failed to send error to Bugsnag: " + e.err.Error()
-}
-
-// NewBugsnagHook initializes a logrus hook which sends exceptions to an
-// exception-tracking service compatible with the Bugsnag API. Before using
-// this hook, you must call bugsnag.Configure(). The returned object should be
-// registered with a log via `AddHook()`
-//
-// Entries that trigger an Error, Fatal or Panic should now include an "error"
-// field to send to Bugsnag.
-func NewBugsnagHook() (*bugsnagHook, error) {
-	if bugsnag.Config.APIKey == "" {
-		return nil, ErrBugsnagUnconfigured
-	}
-	return &bugsnagHook{}, nil
-}
-
-// Fire forwards an error to Bugsnag. Given a logrus.Entry, it extracts the
-// "error" field (or the Message if the error isn't present) and sends it off.
-func (hook *bugsnagHook) Fire(entry *logrus.Entry) error {
-	var notifyErr error
-	err, ok := entry.Data["error"].(error)
-	if ok {
-		notifyErr = err
-	} else {
-		notifyErr = errors.New(entry.Message)
-	}
-
-	bugsnagErr := bugsnag.Notify(notifyErr)
-	if bugsnagErr != nil {
-		return ErrBugsnagSendFailed{bugsnagErr}
-	}
-
-	return nil
-}
-
-// Levels enumerates the log levels on which the error should be forwarded to
-// bugsnag: everything at or above the "Error" level.
-func (hook *bugsnagHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.ErrorLevel,
-		logrus.FatalLevel,
-		logrus.PanicLevel,
-	}
-}
Index: logrus/hooks/bugsnag/bugsnag_test.go
===================================================================
--- logrus.orig/hooks/bugsnag/bugsnag_test.go
+++ /dev/null
@@ -1,64 +0,0 @@
-package logrus_bugsnag
-
-import (
-	"encoding/json"
-	"errors"
-	"io/ioutil"
-	"net/http"
-	"net/http/httptest"
-	"testing"
-	"time"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/bugsnag/bugsnag-go"
-)
-
-type notice struct {
-	Events []struct {
-		Exceptions []struct {
-			Message string `json:"message"`
-		} `json:"exceptions"`
-	} `json:"events"`
-}
-
-func TestNoticeReceived(t *testing.T) {
-	msg := make(chan string, 1)
-	expectedMsg := "foo"
-
-	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		var notice notice
-		data, _ := ioutil.ReadAll(r.Body)
-		if err := json.Unmarshal(data, &notice); err != nil {
-			t.Error(err)
-		}
-		_ = r.Body.Close()
-
-		msg <- notice.Events[0].Exceptions[0].Message
-	}))
-	defer ts.Close()
-
-	hook := &bugsnagHook{}
-
-	bugsnag.Configure(bugsnag.Configuration{
-		Endpoint:     ts.URL,
-		ReleaseStage: "production",
-		APIKey:       "12345678901234567890123456789012",
-		Synchronous:  true,
-	})
-
-	log := logrus.New()
-	log.Hooks.Add(hook)
-
-	log.WithFields(logrus.Fields{
-		"error": errors.New(expectedMsg),
-	}).Error("Bugsnag will not see this string")
-
-	select {
-	case received := <-msg:
-		if received != expectedMsg {
-			t.Errorf("Unexpected message received: %s", received)
-		}
-	case <-time.After(time.Second):
-		t.Error("Timed out; no notice received by Bugsnag API")
-	}
-}
Index: logrus/hooks/papertrail/README.md
===================================================================
--- logrus.orig/hooks/papertrail/README.md
+++ /dev/null
@@ -1,28 +0,0 @@
-# Papertrail Hook for Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:" />
-
-[Papertrail](https://papertrailapp.com) provides hosted log management. Once stored in Papertrail, you can [group](http://help.papertrailapp.com/kb/how-it-works/groups/) your logs on various dimensions, [search](http://help.papertrailapp.com/kb/how-it-works/search-syntax) them, and trigger [alerts](http://help.papertrailapp.com/kb/how-it-works/alerts).
-
-In most deployments, you'll want to send logs to Papertrail via their [remote_syslog](http://help.papertrailapp.com/kb/configuration/configuring-centralized-logging-from-text-log-files-in-unix/) daemon, which requires no application-specific configuration. This hook is intended for relatively low-volume logging, likely in managed cloud hosting deployments where installing `remote_syslog` is not possible.
-
-## Usage
-
-You can find your Papertrail UDP port on your [Papertrail account page](https://papertrailapp.com/account/destinations). Substitute it below for `YOUR_PAPERTRAIL_UDP_PORT`.
-
-For `YOUR_APP_NAME`, substitute a short string that will readily identify your application or service in the logs.
-
-```go
-import (
-  "log/syslog"
-  "github.com/Sirupsen/logrus"
-  "github.com/Sirupsen/logrus/hooks/papertrail"
-)
-
-func main() {
-  log       := logrus.New()
-  hook, err := logrus_papertrail.NewPapertrailHook("logs.papertrailapp.com", YOUR_PAPERTRAIL_UDP_PORT, YOUR_APP_NAME)
-
-  if err == nil {
-    log.Hooks.Add(hook)
-  }
-}
-```
Index: logrus/hooks/papertrail/papertrail.go
===================================================================
--- logrus.orig/hooks/papertrail/papertrail.go
+++ /dev/null
@@ -1,55 +0,0 @@
-package logrus_papertrail
-
-import (
-	"fmt"
-	"net"
-	"os"
-	"time"
-
-	"github.com/Sirupsen/logrus"
-)
-
-const (
-	format = "Jan 2 15:04:05"
-)
-
-// PapertrailHook to send logs to a logging service compatible with the Papertrail API.
-type PapertrailHook struct {
-	Host    string
-	Port    int
-	AppName string
-	UDPConn net.Conn
-}
-
-// NewPapertrailHook creates a hook to be added to an instance of logger.
-func NewPapertrailHook(host string, port int, appName string) (*PapertrailHook, error) {
-	conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", host, port))
-	return &PapertrailHook{host, port, appName, conn}, err
-}
-
-// Fire is called when a log event is fired.
-func (hook *PapertrailHook) Fire(entry *logrus.Entry) error {
-	date := time.Now().Format(format)
-	msg, _ := entry.String()
-	payload := fmt.Sprintf("<22> %s %s: %s", date, hook.AppName, msg)
-
-	bytesWritten, err := hook.UDPConn.Write([]byte(payload))
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Unable to send log line to Papertrail via UDP. Wrote %d bytes before error: %v", bytesWritten, err)
-		return err
-	}
-
-	return nil
-}
-
-// Levels returns the available logging levels.
-func (hook *PapertrailHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.PanicLevel,
-		logrus.FatalLevel,
-		logrus.ErrorLevel,
-		logrus.WarnLevel,
-		logrus.InfoLevel,
-		logrus.DebugLevel,
-	}
-}
Index: logrus/hooks/papertrail/papertrail_test.go
===================================================================
--- logrus.orig/hooks/papertrail/papertrail_test.go
+++ /dev/null
@@ -1,26 +0,0 @@
-package logrus_papertrail
-
-import (
-	"fmt"
-	"testing"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/stvp/go-udp-testing"
-)
-
-func TestWritingToUDP(t *testing.T) {
-	port := 16661
-	udp.SetAddr(fmt.Sprintf(":%d", port))
-
-	hook, err := NewPapertrailHook("localhost", port, "test")
-	if err != nil {
-		t.Errorf("Unable to connect to local UDP server.")
-	}
-
-	log := logrus.New()
-	log.Hooks.Add(hook)
-
-	udp.ShouldReceive(t, "foo", func() {
-		log.Info("foo")
-	})
-}
Index: logrus/hooks/sentry/README.md
===================================================================
--- logrus.orig/hooks/sentry/README.md
+++ /dev/null
@@ -1,61 +0,0 @@
-# Sentry Hook for Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:" />
-
-[Sentry](https://getsentry.com) provides both self-hosted and hosted
-solutions for exception tracking.
-Both client and server are
-[open source](https://github.com/getsentry/sentry).
-
-## Usage
-
-Every sentry application defined on the server gets a different
-[DSN](https://www.getsentry.com/docs/). In the example below replace
-`YOUR_DSN` with the one created for your application.
-
-```go
-import (
-  "github.com/Sirupsen/logrus"
-  "github.com/Sirupsen/logrus/hooks/sentry"
-)
-
-func main() {
-  log       := logrus.New()
-  hook, err := logrus_sentry.NewSentryHook(YOUR_DSN, []logrus.Level{
-    logrus.PanicLevel,
-    logrus.FatalLevel,
-    logrus.ErrorLevel,
-  })
-
-  if err == nil {
-    log.Hooks.Add(hook)
-  }
-}
-```
-
-## Special fields
-
-Some logrus fields have a special meaning in this hook,
-these are server_name and logger.
-When logs are sent to sentry these fields are treated differently.
-- server_name (also known as hostname) is the name of the server which
-is logging the event (hostname.example.com)
-- logger is the part of the application which is logging the event.
-In go this usually means setting it to the name of the package.
-
-## Timeout
-
-`Timeout` is the time the sentry hook will wait for a response
-from the sentry server.
-
-If this time elapses with no response from
-the server an error will be returned.
-
-If `Timeout` is set to 0 the SentryHook will not wait for a reply
-and will assume a correct delivery.
-
-The SentryHook has a default timeout of `100 milliseconds` when created
-with a call to `NewSentryHook`. This can be changed by assigning a value to the `Timeout` field:
-
-```go
-hook, _ := logrus_sentry.NewSentryHook(...)
-hook.Timeout = 20*time.Second
-```
Index: logrus/hooks/sentry/sentry.go
===================================================================
--- logrus.orig/hooks/sentry/sentry.go
+++ /dev/null
@@ -1,100 +0,0 @@
-package logrus_sentry
-
-import (
-	"fmt"
-	"time"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/getsentry/raven-go"
-)
-
-var (
-	severityMap = map[logrus.Level]raven.Severity{
-		logrus.DebugLevel: raven.DEBUG,
-		logrus.InfoLevel:  raven.INFO,
-		logrus.WarnLevel:  raven.WARNING,
-		logrus.ErrorLevel: raven.ERROR,
-		logrus.FatalLevel: raven.FATAL,
-		logrus.PanicLevel: raven.FATAL,
-	}
-)
-
-func getAndDel(d logrus.Fields, key string) (string, bool) {
-	var (
-		ok  bool
-		v   interface{}
-		val string
-	)
-	if v, ok = d[key]; !ok {
-		return "", false
-	}
-
-	if val, ok = v.(string); !ok {
-		return "", false
-	}
-	delete(d, key)
-	return val, true
-}
-
-// SentryHook delivers logs to a sentry server.
-type SentryHook struct {
-	// Timeout sets the time to wait for a delivery error from the sentry server.
-	// If this is set to zero the server will not wait for any response and will
-	// consider the message correctly sent
-	Timeout time.Duration
-
-	client *raven.Client
-	levels []logrus.Level
-}
-
-// NewSentryHook creates a hook to be added to an instance of logger
-// and initializes the raven client.
-// This method sets the timeout to 100 milliseconds.
-func NewSentryHook(DSN string, levels []logrus.Level) (*SentryHook, error) {
-	client, err := raven.NewClient(DSN, nil)
-	if err != nil {
-		return nil, err
-	}
-	return &SentryHook{100 * time.Millisecond, client, levels}, nil
-}
-
-// Called when an event should be sent to sentry
-// Special fields that sentry uses to give more information to the server
-// are extracted from entry.Data (if they are found)
-// These fields are: logger and server_name
-func (hook *SentryHook) Fire(entry *logrus.Entry) error {
-	packet := &raven.Packet{
-		Message:   entry.Message,
-		Timestamp: raven.Timestamp(entry.Time),
-		Level:     severityMap[entry.Level],
-		Platform:  "go",
-	}
-
-	d := entry.Data
-
-	if logger, ok := getAndDel(d, "logger"); ok {
-		packet.Logger = logger
-	}
-	if serverName, ok := getAndDel(d, "server_name"); ok {
-		packet.ServerName = serverName
-	}
-	packet.Extra = map[string]interface{}(d)
-
-	_, errCh := hook.client.Capture(packet, nil)
-	timeout := hook.Timeout
-	if timeout != 0 {
-		timeoutCh := time.After(timeout)
-		select {
-		case err := <-errCh:
-			return err
-		case <-timeoutCh:
-			return fmt.Errorf("no response from sentry server in %s", timeout)
-		}
-	}
-	return nil
-}
-
-// Levels returns the available logging levels.
-func (hook *SentryHook) Levels() []logrus.Level {
-	return hook.levels
-}
Index: logrus/hooks/sentry/sentry_test.go
===================================================================
--- logrus.orig/hooks/sentry/sentry_test.go
+++ /dev/null
@@ -1,97 +0,0 @@
-package logrus_sentry
-
-import (
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"net/http/httptest"
-	"strings"
-	"testing"
-
-	"github.com/Sirupsen/logrus"
-	"github.com/getsentry/raven-go"
-)
-
-const (
-	message     = "error message"
-	server_name = "testserver.internal"
-	logger_name = "test.logger"
-)
-
-func getTestLogger() *logrus.Logger {
-	l := logrus.New()
-	l.Out = ioutil.Discard
-	return l
-}
-
-func WithTestDSN(t *testing.T, tf func(string, <-chan *raven.Packet)) {
-	pch := make(chan *raven.Packet, 1)
-	s := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
-		defer req.Body.Close()
-		d := json.NewDecoder(req.Body)
-		p := &raven.Packet{}
-		err := d.Decode(p)
-		if err != nil {
-			t.Fatal(err.Error())
-		}
-
-		pch <- p
-	}))
-	defer s.Close()
-
-	fragments := strings.SplitN(s.URL, "://", 2)
-	dsn := fmt.Sprintf(
-		"%s://public:secret@%s/sentry/project-id",
-		fragments[0],
-		fragments[1],
-	)
-	tf(dsn, pch)
-}
-
-func TestSpecialFields(t *testing.T) {
-	WithTestDSN(t, func(dsn string, pch <-chan *raven.Packet) {
-		logger := getTestLogger()
-
-		hook, err := NewSentryHook(dsn, []logrus.Level{
-			logrus.ErrorLevel,
-		})
-
-		if err != nil {
-			t.Fatal(err.Error())
-		}
-		logger.Hooks.Add(hook)
-		logger.WithFields(logrus.Fields{
-			"server_name": server_name,
-			"logger":      logger_name,
-		}).Error(message)
-
-		packet := <-pch
-		if packet.Logger != logger_name {
-			t.Errorf("logger should have been %s, was %s", logger_name, packet.Logger)
-		}
-
-		if packet.ServerName != server_name {
-			t.Errorf("server_name should have been %s, was %s", server_name, packet.ServerName)
-		}
-	})
-}
-
-func TestSentryHandler(t *testing.T) {
-	WithTestDSN(t, func(dsn string, pch <-chan *raven.Packet) {
-		logger := getTestLogger()
-		hook, err := NewSentryHook(dsn, []logrus.Level{
-			logrus.ErrorLevel,
-		})
-		if err != nil {
-			t.Fatal(err.Error())
-		}
-		logger.Hooks.Add(hook)
-
-		logger.Error(message)
-		packet := <-pch
-		if packet.Message != message {
-			t.Errorf("message should have been %s, was %s", message, packet.Message)
-		}
-	})
-}
Index: logrus/hooks/syslog/README.md
===================================================================
--- logrus.orig/hooks/syslog/README.md
+++ /dev/null
@@ -1,20 +0,0 @@
-# Syslog Hooks for Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:"/>
-
-## Usage
-
-```go
-import (
-  "log/syslog"
-  "github.com/Sirupsen/logrus"
-  logrus_syslog "github.com/Sirupsen/logrus/hooks/syslog"
-)
-
-func main() {
-  log       := logrus.New()
-  hook, err := logrus_syslog.NewSyslogHook("udp", "localhost:514", syslog.LOG_INFO, "")
-
-  if err == nil {
-    log.Hooks.Add(hook)
-  }
-}
-```
Index: logrus/hooks/syslog/syslog.go
===================================================================
--- logrus.orig/hooks/syslog/syslog.go
+++ /dev/null
@@ -1,59 +0,0 @@
-package logrus_syslog
-
-import (
-	"fmt"
-	"github.com/Sirupsen/logrus"
-	"log/syslog"
-	"os"
-)
-
-// SyslogHook to send logs via syslog.
-type SyslogHook struct {
-	Writer        *syslog.Writer
-	SyslogNetwork string
-	SyslogRaddr   string
-}
-
-// Creates a hook to be added to an instance of logger. This is called with
-// `hook, err := NewSyslogHook("udp", "localhost:514", syslog.LOG_DEBUG, "")`
-// `if err == nil { log.Hooks.Add(hook) }`
-func NewSyslogHook(network, raddr string, priority syslog.Priority, tag string) (*SyslogHook, error) {
-	w, err := syslog.Dial(network, raddr, priority, tag)
-	return &SyslogHook{w, network, raddr}, err
-}
-
-func (hook *SyslogHook) Fire(entry *logrus.Entry) error {
-	line, err := entry.String()
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Unable to read entry, %v", err)
-		return err
-	}
-
-	switch entry.Level {
-	case logrus.PanicLevel:
-		return hook.Writer.Crit(line)
-	case logrus.FatalLevel:
-		return hook.Writer.Crit(line)
-	case logrus.ErrorLevel:
-		return hook.Writer.Err(line)
-	case logrus.WarnLevel:
-		return hook.Writer.Warning(line)
-	case logrus.InfoLevel:
-		return hook.Writer.Info(line)
-	case logrus.DebugLevel:
-		return hook.Writer.Debug(line)
-	default:
-		return nil
-	}
-}
-
-func (hook *SyslogHook) Levels() []logrus.Level {
-	return []logrus.Level{
-		logrus.PanicLevel,
-		logrus.FatalLevel,
-		logrus.ErrorLevel,
-		logrus.WarnLevel,
-		logrus.InfoLevel,
-		logrus.DebugLevel,
-	}
-}
Index: logrus/hooks/syslog/syslog_test.go
===================================================================
--- logrus.orig/hooks/syslog/syslog_test.go
+++ /dev/null
@@ -1,26 +0,0 @@
-package logrus_syslog
-
-import (
-	"github.com/Sirupsen/logrus"
-	"log/syslog"
-	"testing"
-)
-
-func TestLocalhostAddAndPrint(t *testing.T) {
-	log := logrus.New()
-	hook, err := NewSyslogHook("udp", "localhost:514", syslog.LOG_INFO, "")
-
-	if err != nil {
-		t.Errorf("Unable to connect to local syslog.")
-	}
-
-	log.Hooks.Add(hook)
-
-	for _, level := range hook.Levels() {
-		if len(log.Hooks[level]) != 1 {
-			t.Errorf("SyslogHook was not added. The length of log.Hooks[%v]: %v", level, len(log.Hooks[level]))
-		}
-	}
-
-	log.Info("Congratulations!")
-}
